Вторая процентовка по диплому
В модели GameWithPlayers добавил поля: action_preflop, action_flop, action_turn, action_river, для записи действий игрока и ботов, исходя 
из которых мы будем строить дальнейшую логику действий. 
В модель CurrentGame добавил поля small_blind_seat, big_blind_seat. 
Также создал модель для реализации логики изменения мест блайндов.

class CountSeat(models.Model):
    seat_number = models.PositiveIntegerField(default=0)
    
Теперь когда мы начинаем новую игру у нас происходит следующие действия:

seat_1 = CountSeat.objects.get(id=1).seat_number
        if seat_1 != 6:
            seat_1 += 1
            CountSeat.objects.filter(id=1).update(seat_number=seat_1)
        elif seat_1 == 6:
            seat_1 = 1
            CountSeat.objects.filter(id=1).update(seat_number=seat_1)

        seat_2 = 1 if seat_1 == 6 else seat_1 + 1

Места seat_1, seat_2 записываются в модель CurrentGame в поля small_blind_seat, big_blind_seat соответсвенно.
Каждый раз при создании раздачи место малого блайнда будет увеличиваться, пока не станет равным 6, и потом по новой.

После решения этой проблемы я приступил непосредственно к логике, в файле handler_function_for_seat.py лежит ф-ция обработчик:

current_player_position(seat, bb_seat, sb_seat) - которая принимает номер места игрока, и номера места где будет малый и большой блайнд
в текущей раздаче. Возвращает позицию игрока ввидe строки 'EP'.


В файле handlers.py лежит несколько ф-ций оработчиков,

hand_power(card1, card2, position)- принимает карманные карты и позицию игрока за столом и решает подходят ли для игры наши 
карты.

change_position(object) - промежуточная ф-ция обработчик, принимающая позицию ходяшего игрока. С помощью ее частично реализуется
очерередность хода ботов.

Сама очередность хода реализована следующим методом:
Создана модель со значением ходящего игрока.
class PositionOfCurrentPlayer(models.Model):
    status = models.CharField(max_length=10, default='EP', auto_created=True)
После post запроса со странички игры мы достаем значение этого поля, потом из словаря players_positions(смотри StartGame(View))
мы достаем игрока на текущей позиции, далее мы вызываем ф-цию hand_power для определения силы руки, и и потом принимаем решение
играть нам или нет. Также учитывается очередность хода, если мы на EP - значит мы первыми принимаем решение и записываем его в поле
action_preflop модели GameWithPlayers, потом следующий игрок-бот будет проверять значения этого поля у предыдущего игрока, который походил
и уже выдавать свое. Пока что, боты принимают только 3 решения: raise, call, fold. После того как мы завершили работу с игроком, мы
перезарисываем значение поля status, в модели PositionOfCurrentPlayer с помощью ф-ции change_position.
Далее все ходы собираются в список actions, и когда они все будут не равны None мы будем разыгрывать флоп.
Все данные записываются в БД, и полный код можно посмотреть в StartGame(View).

Из вопросов:

Как сделать чтобы мы принимали значения из кнопок Raise, Check, Fold, когда ходит не бот, а пользователь?
конкретнее вот кнопка
<button name="raise_button"
  class="waves-effect waves-light btn-small"
  type="submit" value="raise">Raise
</button>
requst.POST.get('raise_buton') не работает, т.к мы же ничего не посылаем этой кнопкой.

Также может есть способ оптимизировать логику?
